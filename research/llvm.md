This document for the moment is mainly a canvas with different notes.
My idea is to expand it a coherent way in order to have a starting point for when we'll have to write the documentation.

## LLVM passes
Download llvm source & build it
Also need a frontend to obtain llvm intermediate representation.
Passes are responsible for optimization and transformations to the code.
All LLVM passes are subclasses of the Pass class (maybe FunctionPass in our case?).
A compiler pass should live under `/lib/Transforms`, than create a folder for our pass & add the subdirectory inside the `CmakeLists.txt`.
Our pass will be loaded by `opt`, the llvm optimizer, what we are doing is create a shared library for a compiler pass.
After registering our pass we can also specify **when** to run our pass, if before optimization or after.
It seems like every frontend supported by llvm has a `-emit-llvm` flag to obtain just the `.bc` file (maybe now the extension is not `bc` anymore but you got the point -> the `.bc` is the bitcode, i don't think it's even human readable, i have to try it).
Once we have this file we can use `otp`.
With `./bin/opt -load lib/llvmourpass.so -help` you can see all the different things you can do with the compiler pass.
With `-time-passes` we can get the amount of time a pass takes.

(Investigate _CallGraphSCCPass_ class)

### Source
Yt_video:  [Advanced Topics: LLVM Compiler Passes](https://www.youtube.com/watch?v=XK9xG4IGBeU)

### Additional links
[Writing an LLVM pass](https://llvm.org/docs/WritingAnLLVMNewPMPass.html)


## Resources
- [Let’s talk about CFI: clang edition](https://blog.trailofbits.com/2016/10/17/lets-talk-about-cfi-clang-edition/)
- [Let’s talk about CFI: Microsoft Edition](https://blog.trailofbits.com/2016/12/27/lets-talk-about-cfi-microsoft-edition/)
- [Tutto quello che ci serve](https://www.cs.cornell.edu/~asampson/blog/llvm.html), they modify the code
- [A Brief Introduction to LLVM](https://www.youtube.com/watch?v=a5-WaD8VV38) useful to write all the introduction in the documentation
- [Programming Language with LLVM Introduction to LLVM IR and tools](https://www.youtube.com/watch?v=Lvc8qx8ukOI) other cool introduction & also panoramic to the intermediate language file generated by the `llc`, the compiler
## Ideas

### Architecture related stuff
We need to choose a specific target architecture.
Fuck x86, in RISC-V we cannot do anything, there's no support (**maybe check for some pubblications?**), we can only target ARMv8.3 cpus?
If we take a QEMU vm with a ARMv8.3 core, are they implementing that instruction? -> Pietro said yes

### Compiler related stuff
In my mind we don't want to work with a specific frontend, otherwise we will be stuck with just one language.
(Does it have any sense? The llvm IR language will always have function calls and returns? Whatever the language is? I think yes).
So given the fact that we want to work with the llvm IR, we should:
- write a pass (or find one) that exports or generates the control flow graph (the one implemented is part only of clang)
- find a way to add the two instructions if we are targeting a specific arm cpu, the way seems to use [Long live llvm](https://llvm.org/docs/PointerAuth.html)

Is the `.gitignore` already correct for what we need to do? i think so?


## Building
The following command must be modified depending from what you want to install
I already have them on the machine but maybe you want to install also the "high-performance debugger" `lldb`, the linker `lld`and the "high-level loop and data-locality optimizer and optimization infrastructure" `polly` with a flag like `-DLLVM_ENABLE_PROJECTS='lldb;lld;polly'`
Then you can change you destination directory.
I would leave the other flags like this except for the `-DLLVM_USE_LINKER=lld`, if you don't have `lld` installed you cant link the project with it
- cmake -S llvm -B build -G Ninja -DLLVM_ENABLE_PROJECTS='polly' -DCMAKE_BUILD_TYPE=RelWithDebInfo  -DLLVM_ENABLE_ASSERTIONS=ON -DLLVM_USE_LINKER=lld
